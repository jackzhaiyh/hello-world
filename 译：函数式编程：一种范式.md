#译：函数式编程：一种范式

原文链接：https://dzone.com/articles/functional-programming-a-paradigm

作者：[Ayush Prashar](https://dzone.com/users/3367019/ayushprashar.html)

译者：[jackzhaiyh](https://github.com/jackzhaiyh)

函数编程(Functional Programming，FP)的两个要素：纯函数、不可变值。

很难找到函数式编程的一致性定义。但是，我们可以用两个简单的语句描述它。
1、FP是用_纯函数_来编写软件。
2、只能用_不可变值_编写FP。

下面来进一步解释以上两句描述的含义。

## 纯函数

纯函数可以采用以下定义：

- 纯函数的输出仅仅依赖（a）输入和（b）内部算法。不像OOP的方法会依赖同一个类中的其他属性。

- 纯函数没有副作用。它不读取或输出任何值到外部。比如，它不读取文件、web service、UI或者数据库，并且也不向这些对象写值。

- 鉴于以上两个定义，如果使用输入参数x无限次调用纯函数，它将始终返回相同的结果y。例如，每当使用字符串“Ayush”调用“字符串长度”函数时，结果将始终为5。

- 以下为一个纯函数示例：

```java
def sum(firstNumber: Int, secondNumber): Int = {
    firstNumber + secondNumber
}
```

## 不可变值
最好的函数式编程代码就像代数一样，在代数中，你永远不会重用变量。 通过避免重复使用变量，我们可以获得以下好处：
*你始终可以依赖某个值来替换某些功能。 例如，你有_val a = f（x）_。 在这里，你总是可以使用值a作为f（x）的替代，因为它的值不能改变，而_var a = f（x）_的情况则不然。 因此，代数替换是可能的。

```java
val a = f(x)
val b = g(a)
val c = h(b)    
```

- 在这里，a和b永远不会改变; 代码更容易推理。 使用var字段，你总是需要在脑海中运行一个后台线程，“是否在其他地方重新分配？ 留意它。“

- 仅使用不可变值的另一个原因是可变变量（var字段）不适用于并行/并发应用程序。 这样做的原因是，当CPU使用更多内核时，并发性变得越来越重要。

## 函数式编程的好处

- 纯函数更容易推理：

你知道他们不能做某些事情，比如与外界交谈，隐藏输入或修改隐藏状态。 因此，您可以保证他们的功能签名可以告诉您两件事 - （a）确切地说每个函数的输入和（b）每个函数的输出。

- 测试更容易，纯函数非常适合基于属性的测试等技术：

测试纯函数更容易，因为您不必担心它们处理隐藏的状态和副作用。

- 调试更容易：

因为纯函数仅依赖于它们的输入参数来产生它们的输出，所以使用纯函数编写的调试应用程序更容易。 你不必担心应用程序的其余部分发生了什么，你只需要知道那些会使纯函数失败的输入。

- 程序更加防弹：
在FP应用程序中，“移动部件” - 可变变量和隐藏状态比较少，从数学上讲，整体应用程序相对简单。

- 纯函数签名更有意义：
非FP方法可能具有副作用，即这些方法的隐藏输入和输出。最终，他们的函数签名通常没有全面描述函数意义。

```java
def doSomething(): Unit { code here ... }   
```

以上代码不需要输入参数，也不返回任何内容。 因此，没有办法从签名中猜出这种方法的作用。 相反，因为纯函数仅依赖于它们的输入参数来产生它们的输出，所以它们的函数签名非常有意义。

- 并行/并发编程更容易：
函数式程序天然支持并发，无需进一步修改。你永远不必担心死锁和竞争条件，因为不需要使用锁。函数式程序中的任何数据都不会被同一个线程修改两次——更不用说两个不同的线程了。这意味着你可以轻松添加线程，而无需提供困扰并发应用程序的常规问题。

## 函数式编程的缺点

FP也有一些缺点，但不要担心; 每个问题都有办法解决。

- 编写纯函数很容易，但将它们组合成一个完整的应用程序就是事情变得困难的地方：
所有的函数都遵循相同的模式：（1）输入数据，（2）执行算法（转换数据），以及（3）数据输出，粘合纯函数创建完整的FP应用程序是你最大的绊脚石之一。但是，有解决方案，但这是另一天的主题。

- 高级数学术语使FP令人生畏：
当你第一次听到像combinator，monoid，monad和functor这样的术语时，你会发现这些术语令人生畏，恐惧因素成为学习FP的障碍。

- 对于很多人来说，递归并不自然：
对于许多来自OOP范例的程序员来说，递归是一个熟悉的事情，但通常最初会先熟悉一下。 由于不可变值，循环元素的唯一方法是使用递归。 但是，一旦熟悉，使用递归编写代码会更有趣。

- 因为你无法改变现有数据，所以你改为使用我称之为“复制时更新”的模式：
在非FP中变异现有数据非常容易，但在FP中，你要做的是（a）将现有对象复制到新对象，然后当数据的副本从旧对象流向新对象时，以及（b）通过为这些字段提供新值来更新要更改的任何字段。

- 纯函数和I/O并不真正混合

- 仅使用不可变值和递归会导致性能问题，包括RAM使用和速度：

但是，通过使用尾递归可以在很大程度上减少这种情况。

## 结论
FP范例不是OOP的替代品，但它绝对值得学习，因为它提供了一系列惊人的功能，我们已在上面讨论过。 在FP和OOP之间的战斗中很难决定选择哪一方，但我们可以肯定地说，当涉及到并发/并行，数学等时，FP肯定占据上风。我希望你现在公平的看待FP，并准备探索函数式编程范例的世界。

## 参考
Learning FP in Scala By Alvin Alexander

